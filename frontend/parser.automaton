State 0:
file_input' -> . file_input [ # ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 3
-- On list(sep) shift to state 5
-- On file_input shift to state 142
-- On USING reduce production list(sep) -> 
-- On UNDERSCORE reduce production list(sep) -> 
-- On IMPORT reduce production list(sep) -> 
-- On IDENT reduce production list(sep) -> 
-- On FUNCTION reduce production list(sep) -> 
-- On EOF reduce production list(sep) -> 

State 1:
sep -> SEMICOLON . [ USING UNDERSCORE TRUE STRING SEMICOLON RIGHT_STAB RIGHT_FAT RIGHT_CURVY RCURLY PIPE NEWLINE LPAREN LET LCURLY INT64 INT32 INT IN IMPORT IDENT FUNCTION FLOAT FALSE EOF END BEGIN ]
-- On USING reduce production sep -> SEMICOLON 
-- On UNDERSCORE reduce production sep -> SEMICOLON 
-- On TRUE reduce production sep -> SEMICOLON 
-- On STRING reduce production sep -> SEMICOLON 
-- On SEMICOLON reduce production sep -> SEMICOLON 
-- On RIGHT_STAB reduce production sep -> SEMICOLON 
-- On RIGHT_FAT reduce production sep -> SEMICOLON 
-- On RIGHT_CURVY reduce production sep -> SEMICOLON 
-- On RCURLY reduce production sep -> SEMICOLON 
-- On PIPE reduce production sep -> SEMICOLON 
-- On NEWLINE reduce production sep -> SEMICOLON 
-- On LPAREN reduce production sep -> SEMICOLON 
-- On LET reduce production sep -> SEMICOLON 
-- On LCURLY reduce production sep -> SEMICOLON 
-- On INT64 reduce production sep -> SEMICOLON 
-- On INT32 reduce production sep -> SEMICOLON 
-- On INT reduce production sep -> SEMICOLON 
-- On IN reduce production sep -> SEMICOLON 
-- On IMPORT reduce production sep -> SEMICOLON 
-- On IDENT reduce production sep -> SEMICOLON 
-- On FUNCTION reduce production sep -> SEMICOLON 
-- On FLOAT reduce production sep -> SEMICOLON 
-- On FALSE reduce production sep -> SEMICOLON 
-- On EOF reduce production sep -> SEMICOLON 
-- On END reduce production sep -> SEMICOLON 
-- On BEGIN reduce production sep -> SEMICOLON 

State 2:
sep -> NEWLINE . [ USING UNDERSCORE TRUE STRING SEMICOLON RIGHT_STAB RIGHT_FAT RIGHT_CURVY RCURLY PIPE NEWLINE LPAREN LET LCURLY INT64 INT32 INT IN IMPORT IDENT FUNCTION FLOAT FALSE EOF END BEGIN ]
-- On USING reduce production sep -> NEWLINE 
-- On UNDERSCORE reduce production sep -> NEWLINE 
-- On TRUE reduce production sep -> NEWLINE 
-- On STRING reduce production sep -> NEWLINE 
-- On SEMICOLON reduce production sep -> NEWLINE 
-- On RIGHT_STAB reduce production sep -> NEWLINE 
-- On RIGHT_FAT reduce production sep -> NEWLINE 
-- On RIGHT_CURVY reduce production sep -> NEWLINE 
-- On RCURLY reduce production sep -> NEWLINE 
-- On PIPE reduce production sep -> NEWLINE 
-- On NEWLINE reduce production sep -> NEWLINE 
-- On LPAREN reduce production sep -> NEWLINE 
-- On LET reduce production sep -> NEWLINE 
-- On LCURLY reduce production sep -> NEWLINE 
-- On INT64 reduce production sep -> NEWLINE 
-- On INT32 reduce production sep -> NEWLINE 
-- On INT reduce production sep -> NEWLINE 
-- On IN reduce production sep -> NEWLINE 
-- On IMPORT reduce production sep -> NEWLINE 
-- On IDENT reduce production sep -> NEWLINE 
-- On FUNCTION reduce production sep -> NEWLINE 
-- On FLOAT reduce production sep -> NEWLINE 
-- On FALSE reduce production sep -> NEWLINE 
-- On EOF reduce production sep -> NEWLINE 
-- On END reduce production sep -> NEWLINE 
-- On BEGIN reduce production sep -> NEWLINE 

State 3:
list(sep) -> sep . list(sep) [ USING UNDERSCORE TRUE STRING PIPE LPAREN LET LCURLY INT64 INT32 INT IN IMPORT IDENT FUNCTION FLOAT FALSE EOF BEGIN ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 3
-- On list(sep) shift to state 4
-- On USING reduce production list(sep) -> 
-- On UNDERSCORE reduce production list(sep) -> 
-- On TRUE reduce production list(sep) -> 
-- On STRING reduce production list(sep) -> 
-- On PIPE reduce production list(sep) -> 
-- On LPAREN reduce production list(sep) -> 
-- On LET reduce production list(sep) -> 
-- On LCURLY reduce production list(sep) -> 
-- On INT64 reduce production list(sep) -> 
-- On INT32 reduce production list(sep) -> 
-- On INT reduce production list(sep) -> 
-- On IN reduce production list(sep) -> 
-- On IMPORT reduce production list(sep) -> 
-- On IDENT reduce production list(sep) -> 
-- On FUNCTION reduce production list(sep) -> 
-- On FLOAT reduce production list(sep) -> 
-- On FALSE reduce production list(sep) -> 
-- On EOF reduce production list(sep) -> 
-- On BEGIN reduce production list(sep) -> 

State 4:
list(sep) -> sep list(sep) . [ USING UNDERSCORE TRUE STRING PIPE LPAREN LET LCURLY INT64 INT32 INT IN IMPORT IDENT FUNCTION FLOAT FALSE EOF BEGIN ]
-- On USING reduce production list(sep) -> sep list(sep) 
-- On UNDERSCORE reduce production list(sep) -> sep list(sep) 
-- On TRUE reduce production list(sep) -> sep list(sep) 
-- On STRING reduce production list(sep) -> sep list(sep) 
-- On PIPE reduce production list(sep) -> sep list(sep) 
-- On LPAREN reduce production list(sep) -> sep list(sep) 
-- On LET reduce production list(sep) -> sep list(sep) 
-- On LCURLY reduce production list(sep) -> sep list(sep) 
-- On INT64 reduce production list(sep) -> sep list(sep) 
-- On INT32 reduce production list(sep) -> sep list(sep) 
-- On INT reduce production list(sep) -> sep list(sep) 
-- On IN reduce production list(sep) -> sep list(sep) 
-- On IMPORT reduce production list(sep) -> sep list(sep) 
-- On IDENT reduce production list(sep) -> sep list(sep) 
-- On FUNCTION reduce production list(sep) -> sep list(sep) 
-- On FLOAT reduce production list(sep) -> sep list(sep) 
-- On FALSE reduce production list(sep) -> sep list(sep) 
-- On EOF reduce production list(sep) -> sep list(sep) 
-- On BEGIN reduce production list(sep) -> sep list(sep) 

State 5:
file_input -> list(sep) . structure_toplevel EOF [ # ]
-- On USING shift to state 6
-- On UNDERSCORE shift to state 11
-- On IMPORT shift to state 12
-- On IDENT shift to state 14
-- On FUNCTION shift to state 15
-- On structure_toplevel shift to state 132
-- On structure_item_toplevel shift to state 134
-- On structure_item shift to state 136
-- On simple_pattern shift to state 137
-- On list(many_delim(structure_item_toplevel,sep)) shift to state 141
-- On EOF reduce production list(many_delim(structure_item_toplevel,sep)) -> 

State 6:
structure_item_toplevel -> USING . TYPE LBRACKET VERSION_NUMBER RBRACKET [ SEMICOLON NEWLINE ]
-- On TYPE shift to state 7

State 7:
structure_item_toplevel -> USING TYPE . LBRACKET VERSION_NUMBER RBRACKET [ SEMICOLON NEWLINE ]
-- On LBRACKET shift to state 8

State 8:
structure_item_toplevel -> USING TYPE LBRACKET . VERSION_NUMBER RBRACKET [ SEMICOLON NEWLINE ]
-- On VERSION_NUMBER shift to state 9

State 9:
structure_item_toplevel -> USING TYPE LBRACKET VERSION_NUMBER . RBRACKET [ SEMICOLON NEWLINE ]
-- On RBRACKET shift to state 10

State 10:
structure_item_toplevel -> USING TYPE LBRACKET VERSION_NUMBER RBRACKET . [ SEMICOLON NEWLINE ]
-- On SEMICOLON reduce production structure_item_toplevel -> USING TYPE LBRACKET VERSION_NUMBER RBRACKET 
-- On NEWLINE reduce production structure_item_toplevel -> USING TYPE LBRACKET VERSION_NUMBER RBRACKET 

State 11:
simple_pattern -> UNDERSCORE . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LPAREN EQUAL COMMA COLON ]
-- On SEMICOLON reduce production simple_pattern -> UNDERSCORE 
-- On RPAREN reduce production simple_pattern -> UNDERSCORE 
-- On RIGHT_STAB reduce production simple_pattern -> UNDERSCORE 
-- On PIPE reduce production simple_pattern -> UNDERSCORE 
-- On NEWLINE reduce production simple_pattern -> UNDERSCORE 
-- On LPAREN reduce production simple_pattern -> UNDERSCORE 
-- On EQUAL reduce production simple_pattern -> UNDERSCORE 
-- On COMMA reduce production simple_pattern -> UNDERSCORE 
-- On COLON reduce production simple_pattern -> UNDERSCORE 

State 12:
structure_item -> IMPORT . TYPE [ SEMICOLON NEWLINE ]
-- On TYPE shift to state 13

State 13:
structure_item -> IMPORT TYPE . [ SEMICOLON NEWLINE ]
-- On SEMICOLON reduce production structure_item -> IMPORT TYPE 
-- On NEWLINE reduce production structure_item -> IMPORT TYPE 

State 14:
simple_pattern -> IDENT . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LPAREN EQUAL COMMA COLON ]
-- On SEMICOLON reduce production simple_pattern -> IDENT 
-- On RPAREN reduce production simple_pattern -> IDENT 
-- On RIGHT_STAB reduce production simple_pattern -> IDENT 
-- On PIPE reduce production simple_pattern -> IDENT 
-- On NEWLINE reduce production simple_pattern -> IDENT 
-- On LPAREN reduce production simple_pattern -> IDENT 
-- On EQUAL reduce production simple_pattern -> IDENT 
-- On COMMA reduce production simple_pattern -> IDENT 
-- On COLON reduce production simple_pattern -> IDENT 

State 15:
structure_item -> FUNCTION . simple_pattern func_proto_body [ SEMICOLON NEWLINE ]
-- On UNDERSCORE shift to state 11
-- On IDENT shift to state 14
-- On simple_pattern shift to state 16

State 16:
structure_item -> FUNCTION simple_pattern . func_proto_body [ SEMICOLON NEWLINE ]
-- On SEMICOLON shift to state 1
-- On RIGHT_STAB shift to state 17
-- On NEWLINE shift to state 2
-- On LPAREN shift to state 57
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 44
-- On func_proto_tail shift to state 65
-- On func_proto_body shift to state 131

State 17:
func_proto_tail -> RIGHT_STAB . expr [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
func_proto_tail -> RIGHT_STAB . core_type LCURLY list(sep) seq_expr RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
func_proto_tail -> RIGHT_STAB . core_type nonempty_list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On QUOTE shift to state 22
-- On PIPE shift to state 24
-- On LPAREN shift to state 121
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On simple_core_type_or_tuple shift to state 35
-- On simple_core_type shift to state 36
-- On let_main shift to state 73
-- On expr shift to state 122
-- On core_type shift to state 123
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 18:
simple_core_type -> UNDERSCORE . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On SEMICOLON reduce production simple_core_type -> UNDERSCORE 
-- On RPAREN reduce production simple_core_type -> UNDERSCORE 
-- On RIGHT_STAB reduce production simple_core_type -> UNDERSCORE 
-- On PIPE reduce production simple_core_type -> UNDERSCORE 
-- On NEWLINE reduce production simple_core_type -> UNDERSCORE 
-- On LCURLY reduce production simple_core_type -> UNDERSCORE 
-- On EQUAL reduce production simple_core_type -> UNDERSCORE 
-- On COMMA reduce production simple_core_type -> UNDERSCORE 

State 19:
simple_core_type -> TYPE . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On SEMICOLON reduce production simple_core_type -> TYPE 
-- On RPAREN reduce production simple_core_type -> TYPE 
-- On RIGHT_STAB reduce production simple_core_type -> TYPE 
-- On PIPE reduce production simple_core_type -> TYPE 
-- On NEWLINE reduce production simple_core_type -> TYPE 
-- On LCURLY reduce production simple_core_type -> TYPE 
-- On EQUAL reduce production simple_core_type -> TYPE 
-- On COMMA reduce production simple_core_type -> TYPE 

State 20:
constant -> TRUE . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> TRUE 
-- On RPAREN reduce production constant -> TRUE 
-- On RCURLY reduce production constant -> TRUE 
-- On RBRACKET reduce production constant -> TRUE 
-- On NEWLINE reduce production constant -> TRUE 
-- On LPAREN reduce production constant -> TRUE 
-- On LBRACKET reduce production constant -> TRUE 
-- On IN reduce production constant -> TRUE 
-- On END reduce production constant -> TRUE 
-- On COMMA reduce production constant -> TRUE 

State 21:
constant -> STRING . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> STRING 
-- On RPAREN reduce production constant -> STRING 
-- On RCURLY reduce production constant -> STRING 
-- On RBRACKET reduce production constant -> STRING 
-- On NEWLINE reduce production constant -> STRING 
-- On LPAREN reduce production constant -> STRING 
-- On LBRACKET reduce production constant -> STRING 
-- On IN reduce production constant -> STRING 
-- On END reduce production constant -> STRING 
-- On COMMA reduce production constant -> STRING 

State 22:
simple_core_type -> QUOTE . IDENT [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On IDENT shift to state 23

State 23:
simple_core_type -> QUOTE IDENT . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On SEMICOLON reduce production simple_core_type -> QUOTE IDENT 
-- On RPAREN reduce production simple_core_type -> QUOTE IDENT 
-- On RIGHT_STAB reduce production simple_core_type -> QUOTE IDENT 
-- On PIPE reduce production simple_core_type -> QUOTE IDENT 
-- On NEWLINE reduce production simple_core_type -> QUOTE IDENT 
-- On LCURLY reduce production simple_core_type -> QUOTE IDENT 
-- On EQUAL reduce production simple_core_type -> QUOTE IDENT 
-- On COMMA reduce production simple_core_type -> QUOTE IDENT 

State 24:
anon_func -> PIPE . separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On UNDERSCORE shift to state 11
-- On IDENT shift to state 14
-- On simple_pattern shift to state 25
-- On separated_nonempty_list(COMMA,pattern) shift to state 40
-- On pattern shift to state 59

State 25:
pattern -> simple_pattern . [ RPAREN PIPE EQUAL COMMA ]
pattern -> simple_pattern . COLON core_type [ RPAREN PIPE EQUAL COMMA ]
-- On COLON shift to state 26
-- On RPAREN reduce production pattern -> simple_pattern 
-- On PIPE reduce production pattern -> simple_pattern 
-- On EQUAL reduce production pattern -> simple_pattern 
-- On COMMA reduce production pattern -> simple_pattern 

State 26:
pattern -> simple_pattern COLON . core_type [ RPAREN PIPE EQUAL COMMA ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On QUOTE shift to state 22
-- On LPAREN shift to state 27
-- On simple_core_type_or_tuple shift to state 35
-- On simple_core_type shift to state 36
-- On core_type shift to state 37

State 27:
simple_core_type_or_tuple -> LPAREN . simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On QUOTE shift to state 22
-- On simple_core_type shift to state 28

State 28:
simple_core_type_or_tuple -> LPAREN simple_core_type . COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On COMMA shift to state 29

State 29:
simple_core_type_or_tuple -> LPAREN simple_core_type COMMA . separated_nonempty_list(COMMA,simple_core_type) RPAREN [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On QUOTE shift to state 22
-- On simple_core_type shift to state 30
-- On separated_nonempty_list(COMMA,simple_core_type) shift to state 33

State 30:
separated_nonempty_list(COMMA,simple_core_type) -> simple_core_type . [ RPAREN ]
separated_nonempty_list(COMMA,simple_core_type) -> simple_core_type . COMMA separated_nonempty_list(COMMA,simple_core_type) [ RPAREN ]
-- On COMMA shift to state 31
-- On RPAREN reduce production separated_nonempty_list(COMMA,simple_core_type) -> simple_core_type 

State 31:
separated_nonempty_list(COMMA,simple_core_type) -> simple_core_type COMMA . separated_nonempty_list(COMMA,simple_core_type) [ RPAREN ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On QUOTE shift to state 22
-- On simple_core_type shift to state 30
-- On separated_nonempty_list(COMMA,simple_core_type) shift to state 32

State 32:
separated_nonempty_list(COMMA,simple_core_type) -> simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) . [ RPAREN ]
-- On RPAREN reduce production separated_nonempty_list(COMMA,simple_core_type) -> simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) 

State 33:
simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) . RPAREN [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On RPAREN shift to state 34

State 34:
simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On SEMICOLON reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On RPAREN reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On RIGHT_STAB reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On PIPE reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On NEWLINE reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On LCURLY reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On EQUAL reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 
-- On COMMA reduce production simple_core_type_or_tuple -> LPAREN simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN 

State 35:
core_type -> simple_core_type_or_tuple . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On SEMICOLON reduce production core_type -> simple_core_type_or_tuple 
-- On RPAREN reduce production core_type -> simple_core_type_or_tuple 
-- On RIGHT_STAB reduce production core_type -> simple_core_type_or_tuple 
-- On PIPE reduce production core_type -> simple_core_type_or_tuple 
-- On NEWLINE reduce production core_type -> simple_core_type_or_tuple 
-- On LCURLY reduce production core_type -> simple_core_type_or_tuple 
-- On EQUAL reduce production core_type -> simple_core_type_or_tuple 
-- On COMMA reduce production core_type -> simple_core_type_or_tuple 

State 36:
simple_core_type_or_tuple -> simple_core_type . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On SEMICOLON reduce production simple_core_type_or_tuple -> simple_core_type 
-- On RPAREN reduce production simple_core_type_or_tuple -> simple_core_type 
-- On RIGHT_STAB reduce production simple_core_type_or_tuple -> simple_core_type 
-- On PIPE reduce production simple_core_type_or_tuple -> simple_core_type 
-- On NEWLINE reduce production simple_core_type_or_tuple -> simple_core_type 
-- On LCURLY reduce production simple_core_type_or_tuple -> simple_core_type 
-- On EQUAL reduce production simple_core_type_or_tuple -> simple_core_type 
-- On COMMA reduce production simple_core_type_or_tuple -> simple_core_type 

State 37:
core_type -> core_type . RIGHT_STAB core_type [ RPAREN RIGHT_STAB PIPE EQUAL COMMA ]
pattern -> simple_pattern COLON core_type . [ RPAREN PIPE EQUAL COMMA ]
-- On RIGHT_STAB shift to state 38
-- On RPAREN reduce production pattern -> simple_pattern COLON core_type 
-- On PIPE reduce production pattern -> simple_pattern COLON core_type 
-- On EQUAL reduce production pattern -> simple_pattern COLON core_type 
-- On COMMA reduce production pattern -> simple_pattern COLON core_type 

State 38:
core_type -> core_type RIGHT_STAB . core_type [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On QUOTE shift to state 22
-- On LPAREN shift to state 27
-- On simple_core_type_or_tuple shift to state 35
-- On simple_core_type shift to state 36
-- On core_type shift to state 39

State 39:
core_type -> core_type . RIGHT_STAB core_type [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
core_type -> core_type RIGHT_STAB core_type . [ SEMICOLON RPAREN RIGHT_STAB PIPE NEWLINE LCURLY EQUAL COMMA ]
-- On RIGHT_STAB shift to state 38
-- On SEMICOLON reduce production core_type -> core_type RIGHT_STAB core_type 
-- On RPAREN reduce production core_type -> core_type RIGHT_STAB core_type 
-- On PIPE reduce production core_type -> core_type RIGHT_STAB core_type 
-- On NEWLINE reduce production core_type -> core_type RIGHT_STAB core_type 
-- On LCURLY reduce production core_type -> core_type RIGHT_STAB core_type 
-- On EQUAL reduce production core_type -> core_type RIGHT_STAB core_type 
-- On COMMA reduce production core_type -> core_type RIGHT_STAB core_type 

State 40:
anon_func -> PIPE separated_nonempty_list(COMMA,pattern) . PIPE func_proto_tail [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On PIPE shift to state 41

State 41:
anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE . func_proto_tail [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On RIGHT_STAB shift to state 17
-- On NEWLINE shift to state 2
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 44
-- On func_proto_tail shift to state 120

State 42:
nonempty_list(sep) -> sep . [ USING UNDERSCORE TRUE STRING RIGHT_STAB RIGHT_FAT RIGHT_CURVY PIPE LPAREN LET LCURLY INT64 INT32 INT IMPORT IDENT FUNCTION FLOAT FALSE EOF BEGIN ]
nonempty_list(sep) -> sep . nonempty_list(sep) [ USING UNDERSCORE TRUE STRING RIGHT_STAB RIGHT_FAT RIGHT_CURVY PIPE LPAREN LET LCURLY INT64 INT32 INT IMPORT IDENT FUNCTION FLOAT FALSE EOF BEGIN ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 43
-- On USING reduce production nonempty_list(sep) -> sep 
-- On UNDERSCORE reduce production nonempty_list(sep) -> sep 
-- On TRUE reduce production nonempty_list(sep) -> sep 
-- On STRING reduce production nonempty_list(sep) -> sep 
-- On RIGHT_STAB reduce production nonempty_list(sep) -> sep 
-- On RIGHT_FAT reduce production nonempty_list(sep) -> sep 
-- On RIGHT_CURVY reduce production nonempty_list(sep) -> sep 
-- On PIPE reduce production nonempty_list(sep) -> sep 
-- On LPAREN reduce production nonempty_list(sep) -> sep 
-- On LET reduce production nonempty_list(sep) -> sep 
-- On LCURLY reduce production nonempty_list(sep) -> sep 
-- On INT64 reduce production nonempty_list(sep) -> sep 
-- On INT32 reduce production nonempty_list(sep) -> sep 
-- On INT reduce production nonempty_list(sep) -> sep 
-- On IMPORT reduce production nonempty_list(sep) -> sep 
-- On IDENT reduce production nonempty_list(sep) -> sep 
-- On FUNCTION reduce production nonempty_list(sep) -> sep 
-- On FLOAT reduce production nonempty_list(sep) -> sep 
-- On FALSE reduce production nonempty_list(sep) -> sep 
-- On EOF reduce production nonempty_list(sep) -> sep 
-- On BEGIN reduce production nonempty_list(sep) -> sep 

State 43:
nonempty_list(sep) -> sep nonempty_list(sep) . [ USING UNDERSCORE TRUE STRING RIGHT_STAB RIGHT_FAT RIGHT_CURVY PIPE LPAREN LET LCURLY INT64 INT32 INT IMPORT IDENT FUNCTION FLOAT FALSE EOF BEGIN ]
-- On USING reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On UNDERSCORE reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On TRUE reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On STRING reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On RIGHT_STAB reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On RIGHT_FAT reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On RIGHT_CURVY reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On PIPE reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On LPAREN reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On LET reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On LCURLY reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On INT64 reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On INT32 reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On INT reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On IMPORT reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On IDENT reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On FUNCTION reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On FLOAT reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On FALSE reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On EOF reduce production nonempty_list(sep) -> sep nonempty_list(sep) 
-- On BEGIN reduce production nonempty_list(sep) -> sep nonempty_list(sep) 

State 44:
func_proto_tail -> nonempty_list(sep) . seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 118
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 45:
constant -> LPAREN . RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
expr -> LPAREN . expr COMMA separated_nonempty_list(COMMA,expr) RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
simple_expr -> LPAREN . expr RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On RPAREN shift to state 46
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On let_main shift to state 73
-- On expr shift to state 113
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 46:
constant -> LPAREN RPAREN . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> LPAREN RPAREN 
-- On RPAREN reduce production constant -> LPAREN RPAREN 
-- On RCURLY reduce production constant -> LPAREN RPAREN 
-- On RBRACKET reduce production constant -> LPAREN RPAREN 
-- On NEWLINE reduce production constant -> LPAREN RPAREN 
-- On LPAREN reduce production constant -> LPAREN RPAREN 
-- On LBRACKET reduce production constant -> LPAREN RPAREN 
-- On IN reduce production constant -> LPAREN RPAREN 
-- On END reduce production constant -> LPAREN RPAREN 
-- On COMMA reduce production constant -> LPAREN RPAREN 

State 47:
let_main -> LET . list(sep) let_binding_many list(sep) IN list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 3
-- On list(sep) shift to state 48
-- On UNDERSCORE reduce production list(sep) -> 
-- On IDENT reduce production list(sep) -> 

State 48:
let_main -> LET list(sep) . let_binding_many list(sep) IN list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On UNDERSCORE shift to state 11
-- On IDENT shift to state 14
-- On simple_pattern shift to state 25
-- On pattern shift to state 49
-- On let_binding_many shift to state 104
-- On let_binding shift to state 110

State 49:
let_binding -> pattern . EQUAL expr option(sep_bound_call) [ SEMICOLON NEWLINE IN ]
-- On EQUAL shift to state 50

State 50:
let_binding -> pattern EQUAL . expr option(sep_bound_call) [ SEMICOLON NEWLINE IN ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On let_main shift to state 73
-- On expr shift to state 94
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 51:
block -> LCURLY . seq_expr RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 92
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 52:
constant -> INT64 . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> INT64 
-- On RPAREN reduce production constant -> INT64 
-- On RCURLY reduce production constant -> INT64 
-- On RBRACKET reduce production constant -> INT64 
-- On NEWLINE reduce production constant -> INT64 
-- On LPAREN reduce production constant -> INT64 
-- On LBRACKET reduce production constant -> INT64 
-- On IN reduce production constant -> INT64 
-- On END reduce production constant -> INT64 
-- On COMMA reduce production constant -> INT64 

State 53:
constant -> INT32 . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> INT32 
-- On RPAREN reduce production constant -> INT32 
-- On RCURLY reduce production constant -> INT32 
-- On RBRACKET reduce production constant -> INT32 
-- On NEWLINE reduce production constant -> INT32 
-- On LPAREN reduce production constant -> INT32 
-- On LBRACKET reduce production constant -> INT32 
-- On IN reduce production constant -> INT32 
-- On END reduce production constant -> INT32 
-- On COMMA reduce production constant -> INT32 

State 54:
constant -> INT . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> INT 
-- On RPAREN reduce production constant -> INT 
-- On RCURLY reduce production constant -> INT 
-- On RBRACKET reduce production constant -> INT 
-- On NEWLINE reduce production constant -> INT 
-- On LPAREN reduce production constant -> INT 
-- On LBRACKET reduce production constant -> INT 
-- On IN reduce production constant -> INT 
-- On END reduce production constant -> INT 
-- On COMMA reduce production constant -> INT 

State 55:
simple_expr -> IDENT . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production simple_expr -> IDENT 
-- On RPAREN reduce production simple_expr -> IDENT 
-- On RCURLY reduce production simple_expr -> IDENT 
-- On RBRACKET reduce production simple_expr -> IDENT 
-- On NEWLINE reduce production simple_expr -> IDENT 
-- On LPAREN reduce production simple_expr -> IDENT 
-- On LBRACKET reduce production simple_expr -> IDENT 
-- On IN reduce production simple_expr -> IDENT 
-- On END reduce production simple_expr -> IDENT 
-- On COMMA reduce production simple_expr -> IDENT 

State 56:
anon_func -> FUNCTION . func_proto_body [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On RIGHT_STAB shift to state 17
-- On NEWLINE shift to state 2
-- On LPAREN shift to state 57
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 44
-- On func_proto_tail shift to state 65
-- On func_proto_body shift to state 66

State 57:
func_proto_body -> LPAREN . loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On UNDERSCORE shift to state 11
-- On IDENT shift to state 14
-- On simple_pattern shift to state 25
-- On separated_nonempty_list(COMMA,pattern) shift to state 58
-- On pattern shift to state 59
-- On loption(separated_nonempty_list(COMMA,pattern)) shift to state 62
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,pattern)) -> 

State 58:
loption(separated_nonempty_list(COMMA,pattern)) -> separated_nonempty_list(COMMA,pattern) . [ RPAREN ]
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,pattern)) -> separated_nonempty_list(COMMA,pattern) 

State 59:
separated_nonempty_list(COMMA,pattern) -> pattern . [ RPAREN PIPE ]
separated_nonempty_list(COMMA,pattern) -> pattern . COMMA separated_nonempty_list(COMMA,pattern) [ RPAREN PIPE ]
-- On COMMA shift to state 60
-- On RPAREN reduce production separated_nonempty_list(COMMA,pattern) -> pattern 
-- On PIPE reduce production separated_nonempty_list(COMMA,pattern) -> pattern 

State 60:
separated_nonempty_list(COMMA,pattern) -> pattern COMMA . separated_nonempty_list(COMMA,pattern) [ RPAREN PIPE ]
-- On UNDERSCORE shift to state 11
-- On IDENT shift to state 14
-- On simple_pattern shift to state 25
-- On separated_nonempty_list(COMMA,pattern) shift to state 61
-- On pattern shift to state 59

State 61:
separated_nonempty_list(COMMA,pattern) -> pattern COMMA separated_nonempty_list(COMMA,pattern) . [ RPAREN PIPE ]
-- On RPAREN reduce production separated_nonempty_list(COMMA,pattern) -> pattern COMMA separated_nonempty_list(COMMA,pattern) 
-- On PIPE reduce production separated_nonempty_list(COMMA,pattern) -> pattern COMMA separated_nonempty_list(COMMA,pattern) 

State 62:
func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) . RPAREN func_proto_tail [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RPAREN shift to state 63

State 63:
func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN . func_proto_tail [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On RIGHT_STAB shift to state 17
-- On NEWLINE shift to state 2
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 44
-- On func_proto_tail shift to state 64

State 64:
func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On RPAREN reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On RCURLY reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On RBRACKET reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On NEWLINE reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On LPAREN reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On LBRACKET reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On IN reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On END reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 
-- On COMMA reduce production func_proto_body -> LPAREN loption(separated_nonempty_list(COMMA,pattern)) RPAREN func_proto_tail 

State 65:
func_proto_body -> func_proto_tail . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production func_proto_body -> func_proto_tail 
-- On RPAREN reduce production func_proto_body -> func_proto_tail 
-- On RCURLY reduce production func_proto_body -> func_proto_tail 
-- On RBRACKET reduce production func_proto_body -> func_proto_tail 
-- On NEWLINE reduce production func_proto_body -> func_proto_tail 
-- On LPAREN reduce production func_proto_body -> func_proto_tail 
-- On LBRACKET reduce production func_proto_body -> func_proto_tail 
-- On IN reduce production func_proto_body -> func_proto_tail 
-- On END reduce production func_proto_body -> func_proto_tail 
-- On COMMA reduce production func_proto_body -> func_proto_tail 

State 66:
anon_func -> FUNCTION func_proto_body . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production anon_func -> FUNCTION func_proto_body 
-- On RPAREN reduce production anon_func -> FUNCTION func_proto_body 
-- On RCURLY reduce production anon_func -> FUNCTION func_proto_body 
-- On RBRACKET reduce production anon_func -> FUNCTION func_proto_body 
-- On NEWLINE reduce production anon_func -> FUNCTION func_proto_body 
-- On LPAREN reduce production anon_func -> FUNCTION func_proto_body 
-- On LBRACKET reduce production anon_func -> FUNCTION func_proto_body 
-- On IN reduce production anon_func -> FUNCTION func_proto_body 
-- On END reduce production anon_func -> FUNCTION func_proto_body 
-- On COMMA reduce production anon_func -> FUNCTION func_proto_body 

State 67:
constant -> FLOAT . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> FLOAT 
-- On RPAREN reduce production constant -> FLOAT 
-- On RCURLY reduce production constant -> FLOAT 
-- On RBRACKET reduce production constant -> FLOAT 
-- On NEWLINE reduce production constant -> FLOAT 
-- On LPAREN reduce production constant -> FLOAT 
-- On LBRACKET reduce production constant -> FLOAT 
-- On IN reduce production constant -> FLOAT 
-- On END reduce production constant -> FLOAT 
-- On COMMA reduce production constant -> FLOAT 

State 68:
constant -> FALSE . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production constant -> FALSE 
-- On RPAREN reduce production constant -> FALSE 
-- On RCURLY reduce production constant -> FALSE 
-- On RBRACKET reduce production constant -> FALSE 
-- On NEWLINE reduce production constant -> FALSE 
-- On LPAREN reduce production constant -> FALSE 
-- On LBRACKET reduce production constant -> FALSE 
-- On IN reduce production constant -> FALSE 
-- On END reduce production constant -> FALSE 
-- On COMMA reduce production constant -> FALSE 

State 69:
block -> BEGIN . seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 71
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 70:
expr -> simple_expr . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production expr -> simple_expr 
-- On RPAREN reduce production expr -> simple_expr 
-- On RCURLY reduce production expr -> simple_expr 
-- On RBRACKET reduce production expr -> simple_expr 
-- On NEWLINE reduce production expr -> simple_expr 
-- On LPAREN reduce production expr -> simple_expr 
-- On LBRACKET reduce production expr -> simple_expr 
-- On IN reduce production expr -> simple_expr 
-- On END reduce production expr -> simple_expr 
-- On COMMA reduce production expr -> simple_expr 

State 71:
block -> BEGIN seq_expr . END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On END shift to state 72

State 72:
block -> BEGIN seq_expr END . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production block -> BEGIN seq_expr END 
-- On RPAREN reduce production block -> BEGIN seq_expr END 
-- On RCURLY reduce production block -> BEGIN seq_expr END 
-- On RBRACKET reduce production block -> BEGIN seq_expr END 
-- On NEWLINE reduce production block -> BEGIN seq_expr END 
-- On LPAREN reduce production block -> BEGIN seq_expr END 
-- On LBRACKET reduce production block -> BEGIN seq_expr END 
-- On IN reduce production block -> BEGIN seq_expr END 
-- On END reduce production block -> BEGIN seq_expr END 
-- On COMMA reduce production block -> BEGIN seq_expr END 

State 73:
expr -> let_main . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production expr -> let_main 
-- On RPAREN reduce production expr -> let_main 
-- On RCURLY reduce production expr -> let_main 
-- On RBRACKET reduce production expr -> let_main 
-- On NEWLINE reduce production expr -> let_main 
-- On LPAREN reduce production expr -> let_main 
-- On LBRACKET reduce production expr -> let_main 
-- On IN reduce production expr -> let_main 
-- On END reduce production expr -> let_main 
-- On COMMA reduce production expr -> let_main 

State 74:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON RCURLY NEWLINE LPAREN LBRACKET END ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON RCURLY NEWLINE LPAREN LBRACKET END ]
seq_expr -> expr . [ RCURLY END ]
seq_expr -> expr . sep [ RCURLY END ]
seq_expr -> expr . sep seq_expr [ RCURLY END ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On sep shift to state 90
-- On RCURLY reduce production seq_expr -> expr 
-- On END reduce production seq_expr -> expr 

State 75:
call -> expr LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On separated_nonempty_list(COMMA,expr) shift to state 76
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 77
-- On let_main shift to state 73
-- On expr shift to state 79
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) -> 

State 76:
loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) . [ RPAREN RBRACKET ]
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) 
-- On RBRACKET reduce production loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) 

State 77:
call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) . RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RPAREN shift to state 78

State 78:
call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On RPAREN reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On RCURLY reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On RBRACKET reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On NEWLINE reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On LPAREN reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On LBRACKET reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On IN reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On END reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On COMMA reduce production call -> expr LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 

State 79:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ RPAREN RBRACKET LPAREN LBRACKET COMMA ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ RPAREN RBRACKET LPAREN LBRACKET COMMA ]
separated_nonempty_list(COMMA,expr) -> expr . [ RPAREN RBRACKET ]
separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAREN RBRACKET ]
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On COMMA shift to state 88
-- On RPAREN reduce production separated_nonempty_list(COMMA,expr) -> expr 
-- On RBRACKET reduce production separated_nonempty_list(COMMA,expr) -> expr 

State 80:
apply -> expr LBRACKET . loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On separated_nonempty_list(COMMA,expr) shift to state 76
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 81
-- On let_main shift to state 73
-- On expr shift to state 79
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87
-- On RBRACKET reduce production loption(separated_nonempty_list(COMMA,expr)) -> 

State 81:
apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) . RBRACKET [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RBRACKET shift to state 82

State 82:
apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On RPAREN reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On RCURLY reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On RBRACKET reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On NEWLINE reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On LPAREN reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On LBRACKET reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On IN reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On END reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 
-- On COMMA reduce production apply -> expr LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET 

State 83:
simple_expr -> constant . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production simple_expr -> constant 
-- On RPAREN reduce production simple_expr -> constant 
-- On RCURLY reduce production simple_expr -> constant 
-- On RBRACKET reduce production simple_expr -> constant 
-- On NEWLINE reduce production simple_expr -> constant 
-- On LPAREN reduce production simple_expr -> constant 
-- On LBRACKET reduce production simple_expr -> constant 
-- On IN reduce production simple_expr -> constant 
-- On END reduce production simple_expr -> constant 
-- On COMMA reduce production simple_expr -> constant 

State 84:
expr -> call . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production expr -> call 
-- On RPAREN reduce production expr -> call 
-- On RCURLY reduce production expr -> call 
-- On RBRACKET reduce production expr -> call 
-- On NEWLINE reduce production expr -> call 
-- On LPAREN reduce production expr -> call 
-- On LBRACKET reduce production expr -> call 
-- On IN reduce production expr -> call 
-- On END reduce production expr -> call 
-- On COMMA reduce production expr -> call 

State 85:
simple_expr -> block . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production simple_expr -> block 
-- On RPAREN reduce production simple_expr -> block 
-- On RCURLY reduce production simple_expr -> block 
-- On RBRACKET reduce production simple_expr -> block 
-- On NEWLINE reduce production simple_expr -> block 
-- On LPAREN reduce production simple_expr -> block 
-- On LBRACKET reduce production simple_expr -> block 
-- On IN reduce production simple_expr -> block 
-- On END reduce production simple_expr -> block 
-- On COMMA reduce production simple_expr -> block 

State 86:
expr -> apply . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production expr -> apply 
-- On RPAREN reduce production expr -> apply 
-- On RCURLY reduce production expr -> apply 
-- On RBRACKET reduce production expr -> apply 
-- On NEWLINE reduce production expr -> apply 
-- On LPAREN reduce production expr -> apply 
-- On LBRACKET reduce production expr -> apply 
-- On IN reduce production expr -> apply 
-- On END reduce production expr -> apply 
-- On COMMA reduce production expr -> apply 

State 87:
expr -> anon_func . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production expr -> anon_func 
-- On RPAREN reduce production expr -> anon_func 
-- On RCURLY reduce production expr -> anon_func 
-- On RBRACKET reduce production expr -> anon_func 
-- On NEWLINE reduce production expr -> anon_func 
-- On LPAREN reduce production expr -> anon_func 
-- On LBRACKET reduce production expr -> anon_func 
-- On IN reduce production expr -> anon_func 
-- On END reduce production expr -> anon_func 
-- On COMMA reduce production expr -> anon_func 

State 88:
separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RPAREN RBRACKET ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On separated_nonempty_list(COMMA,expr) shift to state 89
-- On let_main shift to state 73
-- On expr shift to state 79
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 89:
separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) . [ RPAREN RBRACKET ]
-- On RPAREN reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) 
-- On RBRACKET reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) 

State 90:
seq_expr -> expr sep . [ RCURLY END ]
seq_expr -> expr sep . seq_expr [ RCURLY END ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 91
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87
-- On RCURLY reduce production seq_expr -> expr sep 
-- On END reduce production seq_expr -> expr sep 

State 91:
seq_expr -> expr sep seq_expr . [ RCURLY END ]
-- On RCURLY reduce production seq_expr -> expr sep seq_expr 
-- On END reduce production seq_expr -> expr sep seq_expr 

State 92:
block -> LCURLY seq_expr . RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RCURLY shift to state 93

State 93:
block -> LCURLY seq_expr RCURLY . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production block -> LCURLY seq_expr RCURLY 
-- On RPAREN reduce production block -> LCURLY seq_expr RCURLY 
-- On RCURLY reduce production block -> LCURLY seq_expr RCURLY 
-- On RBRACKET reduce production block -> LCURLY seq_expr RCURLY 
-- On NEWLINE reduce production block -> LCURLY seq_expr RCURLY 
-- On LPAREN reduce production block -> LCURLY seq_expr RCURLY 
-- On LBRACKET reduce production block -> LCURLY seq_expr RCURLY 
-- On IN reduce production block -> LCURLY seq_expr RCURLY 
-- On END reduce production block -> LCURLY seq_expr RCURLY 
-- On COMMA reduce production block -> LCURLY seq_expr RCURLY 

State 94:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
let_binding -> pattern EQUAL expr . option(sep_bound_call) [ SEMICOLON NEWLINE IN ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On sep shift to state 42
-- On option(sep_bound_call) shift to state 95
-- On nonempty_list(sep) shift to state 96
-- On SEMICOLON reduce production option(sep_bound_call) -> 
-- On NEWLINE reduce production option(sep_bound_call) -> 
-- On IN reduce production option(sep_bound_call) -> 
** Conflict on SEMICOLON NEWLINE

State 95:
let_binding -> pattern EQUAL expr option(sep_bound_call) . [ SEMICOLON NEWLINE IN ]
-- On SEMICOLON reduce production let_binding -> pattern EQUAL expr option(sep_bound_call) 
-- On NEWLINE reduce production let_binding -> pattern EQUAL expr option(sep_bound_call) 
-- On IN reduce production let_binding -> pattern EQUAL expr option(sep_bound_call) 

State 96:
option(sep_bound_call) -> nonempty_list(sep) . bound_call [ SEMICOLON NEWLINE IN ]
-- On RIGHT_STAB shift to state 97
-- On RIGHT_FAT shift to state 99
-- On RIGHT_CURVY shift to state 101
-- On bound_call shift to state 103

State 97:
bound_call -> RIGHT_STAB . expr [ SEMICOLON NEWLINE IN ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On let_main shift to state 73
-- On expr shift to state 98
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 98:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
bound_call -> RIGHT_STAB expr . [ SEMICOLON NEWLINE IN ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On SEMICOLON reduce production bound_call -> RIGHT_STAB expr 
-- On NEWLINE reduce production bound_call -> RIGHT_STAB expr 
-- On IN reduce production bound_call -> RIGHT_STAB expr 

State 99:
bound_call -> RIGHT_FAT . expr [ SEMICOLON NEWLINE IN ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On let_main shift to state 73
-- On expr shift to state 100
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 100:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
bound_call -> RIGHT_FAT expr . [ SEMICOLON NEWLINE IN ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On SEMICOLON reduce production bound_call -> RIGHT_FAT expr 
-- On NEWLINE reduce production bound_call -> RIGHT_FAT expr 
-- On IN reduce production bound_call -> RIGHT_FAT expr 

State 101:
bound_call -> RIGHT_CURVY . expr [ SEMICOLON NEWLINE IN ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On let_main shift to state 73
-- On expr shift to state 102
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 102:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
bound_call -> RIGHT_CURVY expr . [ SEMICOLON NEWLINE IN ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON NEWLINE LPAREN LBRACKET IN ]
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On SEMICOLON reduce production bound_call -> RIGHT_CURVY expr 
-- On NEWLINE reduce production bound_call -> RIGHT_CURVY expr 
-- On IN reduce production bound_call -> RIGHT_CURVY expr 

State 103:
option(sep_bound_call) -> nonempty_list(sep) bound_call . [ SEMICOLON NEWLINE IN ]
-- On SEMICOLON reduce production option(sep_bound_call) -> nonempty_list(sep) bound_call 
-- On NEWLINE reduce production option(sep_bound_call) -> nonempty_list(sep) bound_call 
-- On IN reduce production option(sep_bound_call) -> nonempty_list(sep) bound_call 

State 104:
let_main -> LET list(sep) let_binding_many . list(sep) IN list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 3
-- On list(sep) shift to state 105
-- On IN reduce production list(sep) -> 

State 105:
let_main -> LET list(sep) let_binding_many list(sep) . IN list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On IN shift to state 106

State 106:
let_main -> LET list(sep) let_binding_many list(sep) IN . list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 3
-- On list(sep) shift to state 107
-- On TRUE reduce production list(sep) -> 
-- On STRING reduce production list(sep) -> 
-- On PIPE reduce production list(sep) -> 
-- On LPAREN reduce production list(sep) -> 
-- On LET reduce production list(sep) -> 
-- On LCURLY reduce production list(sep) -> 
-- On INT64 reduce production list(sep) -> 
-- On INT32 reduce production list(sep) -> 
-- On INT reduce production list(sep) -> 
-- On IDENT reduce production list(sep) -> 
-- On FUNCTION reduce production list(sep) -> 
-- On FLOAT reduce production list(sep) -> 
-- On FALSE reduce production list(sep) -> 
-- On BEGIN reduce production list(sep) -> 

State 107:
let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) . seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 108
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 108:
let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr . END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On END shift to state 109

State 109:
let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On RPAREN reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On RCURLY reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On RBRACKET reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On NEWLINE reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On LPAREN reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On LBRACKET reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On IN reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On END reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 
-- On COMMA reduce production let_main -> LET list(sep) let_binding_many list(sep) IN list(sep) seq_expr END 

State 110:
let_binding_many -> let_binding . [ SEMICOLON NEWLINE IN ]
let_binding_many -> let_binding . nonempty_list(sep) let_binding_many [ SEMICOLON NEWLINE IN ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 111
-- On SEMICOLON reduce production let_binding_many -> let_binding 
-- On NEWLINE reduce production let_binding_many -> let_binding 
-- On IN reduce production let_binding_many -> let_binding 
** Conflict on SEMICOLON NEWLINE

State 111:
let_binding_many -> let_binding nonempty_list(sep) . let_binding_many [ SEMICOLON NEWLINE IN ]
-- On UNDERSCORE shift to state 11
-- On IDENT shift to state 14
-- On simple_pattern shift to state 25
-- On pattern shift to state 49
-- On let_binding_many shift to state 112
-- On let_binding shift to state 110

State 112:
let_binding_many -> let_binding nonempty_list(sep) let_binding_many . [ SEMICOLON NEWLINE IN ]
-- On SEMICOLON reduce production let_binding_many -> let_binding nonempty_list(sep) let_binding_many 
-- On NEWLINE reduce production let_binding_many -> let_binding nonempty_list(sep) let_binding_many 
-- On IN reduce production let_binding_many -> let_binding nonempty_list(sep) let_binding_many 

State 113:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ RPAREN LPAREN LBRACKET COMMA ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ RPAREN LPAREN LBRACKET COMMA ]
expr -> LPAREN expr . COMMA separated_nonempty_list(COMMA,expr) RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
simple_expr -> LPAREN expr . RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RPAREN shift to state 114
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On COMMA shift to state 115

State 114:
simple_expr -> LPAREN expr RPAREN . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production simple_expr -> LPAREN expr RPAREN 
-- On RPAREN reduce production simple_expr -> LPAREN expr RPAREN 
-- On RCURLY reduce production simple_expr -> LPAREN expr RPAREN 
-- On RBRACKET reduce production simple_expr -> LPAREN expr RPAREN 
-- On NEWLINE reduce production simple_expr -> LPAREN expr RPAREN 
-- On LPAREN reduce production simple_expr -> LPAREN expr RPAREN 
-- On LBRACKET reduce production simple_expr -> LPAREN expr RPAREN 
-- On IN reduce production simple_expr -> LPAREN expr RPAREN 
-- On END reduce production simple_expr -> LPAREN expr RPAREN 
-- On COMMA reduce production simple_expr -> LPAREN expr RPAREN 

State 115:
expr -> LPAREN expr COMMA . separated_nonempty_list(COMMA,expr) RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On separated_nonempty_list(COMMA,expr) shift to state 116
-- On let_main shift to state 73
-- On expr shift to state 79
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 116:
expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) . RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RPAREN shift to state 117

State 117:
expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On RPAREN reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On RCURLY reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On RBRACKET reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On NEWLINE reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On LPAREN reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On LBRACKET reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On IN reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On END reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 
-- On COMMA reduce production expr -> LPAREN expr COMMA separated_nonempty_list(COMMA,expr) RPAREN 

State 118:
func_proto_tail -> nonempty_list(sep) seq_expr . END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On END shift to state 119

State 119:
func_proto_tail -> nonempty_list(sep) seq_expr END . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On RPAREN reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On RCURLY reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On RBRACKET reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On NEWLINE reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On LPAREN reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On LBRACKET reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On IN reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On END reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 
-- On COMMA reduce production func_proto_tail -> nonempty_list(sep) seq_expr END 

State 120:
anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On RPAREN reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On RCURLY reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On RBRACKET reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On NEWLINE reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On LPAREN reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On LBRACKET reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On IN reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On END reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 
-- On COMMA reduce production anon_func -> PIPE separated_nonempty_list(COMMA,pattern) PIPE func_proto_tail 

State 121:
constant -> LPAREN . RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
expr -> LPAREN . expr COMMA separated_nonempty_list(COMMA,expr) RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
simple_core_type_or_tuple -> LPAREN . simple_core_type COMMA separated_nonempty_list(COMMA,simple_core_type) RPAREN [ SEMICOLON RIGHT_STAB NEWLINE LCURLY ]
simple_expr -> LPAREN . expr RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On UNDERSCORE shift to state 18
-- On TYPE shift to state 19
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On RPAREN shift to state 46
-- On QUOTE shift to state 22
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On simple_core_type shift to state 28
-- On let_main shift to state 73
-- On expr shift to state 113
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 122:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
func_proto_tail -> RIGHT_STAB expr . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On SEMICOLON reduce production func_proto_tail -> RIGHT_STAB expr 
-- On RPAREN reduce production func_proto_tail -> RIGHT_STAB expr 
-- On RCURLY reduce production func_proto_tail -> RIGHT_STAB expr 
-- On RBRACKET reduce production func_proto_tail -> RIGHT_STAB expr 
-- On NEWLINE reduce production func_proto_tail -> RIGHT_STAB expr 
-- On IN reduce production func_proto_tail -> RIGHT_STAB expr 
-- On END reduce production func_proto_tail -> RIGHT_STAB expr 
-- On COMMA reduce production func_proto_tail -> RIGHT_STAB expr 

State 123:
core_type -> core_type . RIGHT_STAB core_type [ SEMICOLON RIGHT_STAB NEWLINE LCURLY ]
func_proto_tail -> RIGHT_STAB core_type . LCURLY list(sep) seq_expr RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
func_proto_tail -> RIGHT_STAB core_type . nonempty_list(sep) seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On RIGHT_STAB shift to state 38
-- On NEWLINE shift to state 2
-- On LCURLY shift to state 124
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 128

State 124:
func_proto_tail -> RIGHT_STAB core_type LCURLY . list(sep) seq_expr RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 3
-- On list(sep) shift to state 125
-- On TRUE reduce production list(sep) -> 
-- On STRING reduce production list(sep) -> 
-- On PIPE reduce production list(sep) -> 
-- On LPAREN reduce production list(sep) -> 
-- On LET reduce production list(sep) -> 
-- On LCURLY reduce production list(sep) -> 
-- On INT64 reduce production list(sep) -> 
-- On INT32 reduce production list(sep) -> 
-- On INT reduce production list(sep) -> 
-- On IDENT reduce production list(sep) -> 
-- On FUNCTION reduce production list(sep) -> 
-- On FLOAT reduce production list(sep) -> 
-- On FALSE reduce production list(sep) -> 
-- On BEGIN reduce production list(sep) -> 

State 125:
func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) . seq_expr RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 126
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 126:
func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr . RCURLY [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On RCURLY shift to state 127

State 127:
func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On RPAREN reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On RCURLY reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On RBRACKET reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On NEWLINE reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On LPAREN reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On LBRACKET reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On IN reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On END reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 
-- On COMMA reduce production func_proto_tail -> RIGHT_STAB core_type LCURLY list(sep) seq_expr RCURLY 

State 128:
func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) . seq_expr END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On seq_expr shift to state 129
-- On let_main shift to state 73
-- On expr shift to state 74
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 129:
func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr . END [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On END shift to state 130

State 130:
func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END . [ SEMICOLON RPAREN RCURLY RBRACKET NEWLINE LPAREN LBRACKET IN END COMMA ]
-- On SEMICOLON reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On RPAREN reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On RCURLY reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On RBRACKET reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On NEWLINE reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On LPAREN reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On LBRACKET reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On IN reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On END reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 
-- On COMMA reduce production func_proto_tail -> RIGHT_STAB core_type nonempty_list(sep) seq_expr END 

State 131:
structure_item -> FUNCTION simple_pattern func_proto_body . [ SEMICOLON NEWLINE ]
-- On SEMICOLON reduce production structure_item -> FUNCTION simple_pattern func_proto_body 
-- On NEWLINE reduce production structure_item -> FUNCTION simple_pattern func_proto_body 

State 132:
file_input -> list(sep) structure_toplevel . EOF [ # ]
-- On EOF shift to state 133

State 133:
file_input -> list(sep) structure_toplevel EOF . [ # ]
-- On # reduce production file_input -> list(sep) structure_toplevel EOF 

State 134:
list(many_delim(structure_item_toplevel,sep)) -> structure_item_toplevel . nonempty_list(sep) list(many_delim(structure_item_toplevel,sep)) [ EOF ]
-- On SEMICOLON shift to state 1
-- On NEWLINE shift to state 2
-- On sep shift to state 42
-- On nonempty_list(sep) shift to state 135

State 135:
list(many_delim(structure_item_toplevel,sep)) -> structure_item_toplevel nonempty_list(sep) . list(many_delim(structure_item_toplevel,sep)) [ EOF ]
-- On USING shift to state 6
-- On UNDERSCORE shift to state 11
-- On IMPORT shift to state 12
-- On IDENT shift to state 14
-- On FUNCTION shift to state 15
-- On structure_item_toplevel shift to state 134
-- On structure_item shift to state 136
-- On simple_pattern shift to state 137
-- On list(many_delim(structure_item_toplevel,sep)) shift to state 140
-- On EOF reduce production list(many_delim(structure_item_toplevel,sep)) -> 

State 136:
structure_item_toplevel -> structure_item . [ SEMICOLON NEWLINE ]
-- On SEMICOLON reduce production structure_item_toplevel -> structure_item 
-- On NEWLINE reduce production structure_item_toplevel -> structure_item 

State 137:
structure_item -> simple_pattern . EQUAL expr [ SEMICOLON NEWLINE ]
-- On EQUAL shift to state 138

State 138:
structure_item -> simple_pattern EQUAL . expr [ SEMICOLON NEWLINE ]
-- On TRUE shift to state 20
-- On STRING shift to state 21
-- On PIPE shift to state 24
-- On LPAREN shift to state 45
-- On LET shift to state 47
-- On LCURLY shift to state 51
-- On INT64 shift to state 52
-- On INT32 shift to state 53
-- On INT shift to state 54
-- On IDENT shift to state 55
-- On FUNCTION shift to state 56
-- On FLOAT shift to state 67
-- On FALSE shift to state 68
-- On BEGIN shift to state 69
-- On simple_expr shift to state 70
-- On let_main shift to state 73
-- On expr shift to state 139
-- On constant shift to state 83
-- On call shift to state 84
-- On block shift to state 85
-- On apply shift to state 86
-- On anon_func shift to state 87

State 139:
apply -> expr . LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ SEMICOLON NEWLINE LPAREN LBRACKET ]
call -> expr . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN [ SEMICOLON NEWLINE LPAREN LBRACKET ]
structure_item -> simple_pattern EQUAL expr . [ SEMICOLON NEWLINE ]
-- On LPAREN shift to state 75
-- On LBRACKET shift to state 80
-- On SEMICOLON reduce production structure_item -> simple_pattern EQUAL expr 
-- On NEWLINE reduce production structure_item -> simple_pattern EQUAL expr 

State 140:
list(many_delim(structure_item_toplevel,sep)) -> structure_item_toplevel nonempty_list(sep) list(many_delim(structure_item_toplevel,sep)) . [ EOF ]
-- On EOF reduce production list(many_delim(structure_item_toplevel,sep)) -> structure_item_toplevel nonempty_list(sep) list(many_delim(structure_item_toplevel,sep)) 

State 141:
structure_toplevel -> list(many_delim(structure_item_toplevel,sep)) . [ EOF ]
-- On EOF reduce production structure_toplevel -> list(many_delim(structure_item_toplevel,sep)) 

State 142:
file_input' -> file_input . [ # ]
-- On # accept file_input

